<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe 3D Ultimate</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #gameCanvas:active {
            cursor: grabbing;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        
        h1 {
            font-size: 3em;
            font-weight: 900;
            letter-spacing: 0.15em;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255,255,255,0.2);
            animation: glow 3s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
        
        #info {
            font-size: 1.4em;
            color: #fff;
            text-shadow: 0 0 10px currentColor;
            margin-bottom: 10px;
        }
        
        #winner {
            font-size: 2em;
            font-weight: 700;
            height: 40px;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        #settings {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            pointer-events: all;
            z-index: 15;
            backdrop-filter: blur(20px);
            display: none;
            min-width: 300px;
            max-width: 50%;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        #settings.show {
            display: block;
            animation: modalFadeIn 0.3s ease-out;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        
        #settingsOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 14;
            display: none;
        }
        
        #settingsOverlay.show {
            display: block;
        }
        
        #settingsBtn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            pointer-events: all;
            z-index: 10;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            font-size: 24px;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        #settingsBtn:hover {
            transform: scale(1.1);
            background: rgba(0, 255, 255, 0.1);
        }
        
        #gameControls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: all;
            z-index: 10;
        }
        
        .control-btn {
            padding: 12px 25px;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            font-weight: 700;
            background: rgba(255, 255, 255, 0.05);
            color: #00ffff;
            border: 2px solid #00ffff;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            backdrop-filter: blur(20px);
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 30px rgba(0, 255, 255, 0.4);
            background: rgba(0, 255, 255, 0.1);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #settings h3 {
            margin-right: 30px;
            margin-bottom: 20px;
            color: #00ffff;
            font-size: 1.4em;
            text-align: center;
        }
        
        .setting-item {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .toggle {
            width: 50px;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 25px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .toggle.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        .toggle-knob {
            width: 19px;
            height: 19px;
            background: #666;
            border-radius: 50%;
            position: absolute;
            top: 1px;
            left: 1px;
            transition: all 0.3s;
        }
        
        .toggle.active .toggle-knob {
            left: 26px;
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .player-x {
            color: #ff00ff;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }
        
        .player-o {
            color: #00ff00;
            text-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }
        
        .player-z {
            color: #ffaa00;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.8);
        }
        
        #settings .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            border: none;
            background: transparent;
            color: #00ffff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        #settings .close-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: rotate(90deg);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <h1>TIC-TAC-TOE 3D</h1>
        <div id="info">PLAYER <span class="player-x">X</span> TURN</div>
        <div id="winner"></div>
    </div>
    
    <div id="gameControls">
        <button class="control-btn" onclick="resetGame()">NEW GAME</button>
        <button class="control-btn" onclick="resetCamera()">RESET VIEW</button>
    </div>
    
    <button id="settingsBtn" onclick="toggleSettings()">⚙️</button>
    
    <div id="settingsOverlay"></div>
    <div id="settings">
        <button class="close-btn" onclick="toggleSettings()">×</button>
        <h3>SETTINGS</h3>
        <div class="setting-item">
            <label>Hide Center</label>
            <div class="toggle" id="hideCenterToggle" onclick="toggleHideCenter()">
                <div class="toggle-knob"></div>
            </div>
        </div>
        <div class="setting-item">
            <label>3 Players Mode</label>
            <div class="toggle" id="threePlayersToggle" onclick="toggleThreePlayers()">
                <div class="toggle-knob"></div>
            </div>
        </div>
        <div class="setting-item">
            <label>Auto Rotate</label>
            <div class="toggle active" id="autoRotateToggle" onclick="toggleAutoRotate()">
                <div class="toggle-knob"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let cubeGroup, symbolsGroup;
        let cells = [];
        let gameState = [];
        let currentPlayer = 'X';
        let gameOver = false;
        let raycaster, mouse;
        let controls;
        
        // Settings
        let autoRotate = true;
        let hideCenter = false;
        let threePlayers = false;
        let players = ['X', 'O'];
        let playerColors = {
            'X': 0xff00ff,
            'O': 0x00ff00,
            'Z': 0xffaa00
        };
        
        // Mouse/Touch controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        
        // Inicializar el estado del juego
        function initGameState() {
            gameState = [];
            for (let i = 0; i < 3; i++) {
                gameState[i] = [];
                for (let j = 0; j < 3; j++) {
                    gameState[i][j] = [];
                    for (let k = 0; k < 3; k++) {
                        gameState[i][j][k] = null;
                    }
                }
            }
        }
        
        function init() {
            // Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 5, 15);
            
            // Cámara
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(5, 4, 5);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Luces ambiente
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            
            // Luz direccional principal
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            // Luces de colores
            const lights = [
                { color: 0x00ffff, position: [8, 5, 8], intensity: 0.8 },
                { color: 0xff00ff, position: [-8, 5, -8], intensity: 0.8 },
                { color: 0x00ff00, position: [0, 10, 0], intensity: 0.6 }
            ];
            
            lights.forEach(light => {
                const pointLight = new THREE.PointLight(light.color, light.intensity, 20);
                pointLight.position.set(...light.position);
                scene.add(pointLight);
            });
            
            // Grupos
            cubeGroup = new THREE.Group();
            symbolsGroup = new THREE.Group();
            scene.add(cubeGroup);
            scene.add(symbolsGroup);
            
            // Partículas de fondo
            createParticles();
            
            // Crear las celdas del cubo
            initGameState();
            createCube();
            
            // Raycaster para detectar clics
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Event listeners
            setupEventListeners();
            
            // Iniciar animación
            animate();
        }
        
        function createParticles() {
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 1000;
            const posArray = new Float32Array(particlesCount * 3);
            
            for (let i = 0; i < particlesCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 20;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.02,
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
        }
        
        function createCube() {
            const cellSize = 0.8;
            const spacing = 1.2;
            
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        // Skip center if hideCenter is true
                        if (hideCenter && x === 1 && y === 1 && z === 1) {
                            continue;
                        }
                        
                        // Crear grupo para la celda
                        const cellGroup = new THREE.Group();
                        
                        // Geometría del cubo con bordes redondeados (simulado)
                        const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                        
                        // Material glass-like
                        const material = new THREE.MeshPhysicalMaterial({
                            color: 0x00ffff,
                            metalness: 0.1,
                            roughness: 0.1,
                            transmission: 0.9,
                            transparent: true,
                            opacity: 0.1,
                            envMapIntensity: 1,
                            clearcoat: 1,
                            clearcoatRoughness: 0
                        });
                        
                        const cubeMesh = new THREE.Mesh(geometry, material);
                        cubeMesh.castShadow = true;
                        cubeMesh.receiveShadow = true;
                        cellGroup.add(cubeMesh);
                        
                        // Bordes brillantes
                        const edges = new THREE.EdgesGeometry(geometry);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.6,
                            linewidth: 2
                        });
                        const wireframe = new THREE.LineSegments(edges, lineMaterial);
                        cellGroup.add(wireframe);
                        
                        // Añadir glow effect
                        const glowGeometry = new THREE.BoxGeometry(cellSize * 1.1, cellSize * 1.1, cellSize * 1.1);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.05,
                            side: THREE.BackSide
                        });
                        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                        cellGroup.add(glowMesh);
                        
                        // Datos de la celda
                        cubeMesh.userData = { 
                            x, y, z, 
                            occupied: false, 
                            wireframe: wireframe,
                            material: material,
                            glowMesh: glowMesh,
                            cellGroup: cellGroup
                        };
                        
                        // Posicionar celda
                        cellGroup.position.set(
                            (x - 1) * spacing,
                            (y - 1) * spacing,
                            (z - 1) * spacing
                        );
                        
                        cells.push(cubeMesh);
                        cubeGroup.add(cellGroup);
                    }
                }
            }
        }
        
        function createX(position, cellGroup) {
            const group = new THREE.Group();
            
            // Material con emisión
            const material = new THREE.MeshPhysicalMaterial({ 
                color: playerColors['X'],
                emissive: playerColors['X'],
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            
            // Crear X con cilindros mejorados
            const geometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 32);
            
            const bar1 = new THREE.Mesh(geometry, material);
            bar1.rotation.z = Math.PI / 4;
            bar1.castShadow = true;
            group.add(bar1);
            
            const bar2 = new THREE.Mesh(geometry, material);
            bar2.rotation.z = -Math.PI / 4;
            bar2.castShadow = true;
            group.add(bar2);
            
            // Efecto de brillo
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: playerColors['X'],
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glowGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.7, 32);
            
            const glow1 = new THREE.Mesh(glowGeometry, glowMaterial);
            glow1.rotation.z = Math.PI / 4;
            group.add(glow1);
            
            const glow2 = new THREE.Mesh(glowGeometry, glowMaterial);
            glow2.rotation.z = -Math.PI / 4;
            group.add(glow2);
            
            // Añadir al grupo de la celda para que rote con ella
            cellGroup.add(group);
            
            // Animación de entrada
            group.scale.set(0, 0, 0);
            animateScale(group, 1);
            
            return group;
        }
        
        function createO(position, cellGroup) {
            const group = new THREE.Group();
            
            // Torus con material mejorado
            const geometry = new THREE.TorusGeometry(0.25, 0.08, 32, 100);
            const material = new THREE.MeshPhysicalMaterial({ 
                color: playerColors['O'],
                emissive: playerColors['O'],
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const torus = new THREE.Mesh(geometry, material);
            torus.castShadow = true;
            group.add(torus);
            
            // Efecto de brillo
            const glowGeometry = new THREE.TorusGeometry(0.25, 0.12, 16, 100);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: playerColors['O'],
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            // Añadir al grupo de la celda
            cellGroup.add(group);
            
            // Animación de entrada
            group.scale.set(0, 0, 0);
            animateScale(group, 1);
            
            return group;
        }
        
        function createZ(position, cellGroup) {
            const group = new THREE.Group();
            
            // Material para Z (triángulo/pirámide)
            const material = new THREE.MeshPhysicalMaterial({ 
                color: playerColors['Z'],
                emissive: playerColors['Z'],
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            
            // Crear pirámide
            const geometry = new THREE.ConeGeometry(0.3, 0.6, 4);
            const pyramid = new THREE.Mesh(geometry, material);
            pyramid.rotation.y = Math.PI / 4;
            pyramid.castShadow = true;
            group.add(pyramid);
            
            // Efecto de brillo
            const glowGeometry = new THREE.ConeGeometry(0.35, 0.65, 4);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: playerColors['Z'],
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.rotation.y = Math.PI / 4;
            group.add(glow);
            
            // Añadir al grupo de la celda
            cellGroup.add(group);
            
            // Animación de entrada
            group.scale.set(0, 0, 0);
            animateScale(group, 1);
            
            return group;
        }
        
        function animateScale(object, targetScale) {
            const duration = 400;
            const startTime = Date.now();
            const startScale = object.scale.x;
            
            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function
                const eased = 1 - Math.pow(1 - progress, 4);
                
                const scale = startScale + (targetScale - startScale) * eased;
                object.scale.setScalar(scale);
                
                // Rotación durante la animación
                object.rotation.y = progress * Math.PI * 2;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            update();
        }
        
        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // Touch events
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                // Rotación más suave y responsiva
                targetRotation.y += deltaMove.x * 0.02;
                targetRotation.x += deltaMove.y * 0.02;
                
                // Limitar la rotación vertical para evitar que el cubo se voltee
                targetRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotation.x));
                
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            } else {
                // Hover effect
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cells);
                
                // Reset todos los efectos hover
                cells.forEach(cell => {
                    if (!cell.userData.occupied) {
                        cell.userData.wireframe.material.opacity = 0.6;
                        cell.userData.wireframe.material.color.setHex(0x00ffff);
                        cell.userData.glowMesh.material.opacity = 0.05;
                        cell.userData.material.opacity = 0.1;
                    }
                });
                
                // Aplicar efecto hover
                if (intersects.length > 0 && !gameOver) {
                    const hoveredCell = intersects[0].object;
                    if (!hoveredCell.userData.occupied) {
                        hoveredCell.userData.wireframe.material.opacity = 1;
                        hoveredCell.userData.wireframe.material.color.setHex(0xffffff);
                        hoveredCell.userData.glowMesh.material.opacity = 0.2;
                        hoveredCell.userData.material.opacity = 0.3;
                        
                        // Animar el grosor de los bordes
                        const scale = 1 + Math.sin(Date.now() * 0.005) * 0.05;
                        hoveredCell.userData.cellGroup.scale.setScalar(scale);
                        
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    document.body.style.cursor = isDragging ? 'grabbing' : 'grab';
                }
            }
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseClick(event) {
            if (gameOver || isDragging) return;
            
            // Prevenir click si estaba arrastrando
            if (Math.abs(targetRotation.x - currentRotation.x) > 0.1 || 
                Math.abs(targetRotation.y - currentRotation.y) > 0.1) {
                return;
            }
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cells);
            
            if (intersects.length > 0) {
                const cell = intersects[0].object;
                const { x, y, z, occupied } = cell.userData;
                
                if (!occupied) {
                    makeMove(cell, x, y, z);
                }
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            isDragging = true;
            previousMousePosition = {
                x: touch.clientX,
                y: touch.clientY
            };
            
            // Verificar si el toque está sobre una celda
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cells);
            
            if (intersects.length > 0 && !gameOver) {
                const cell = intersects[0].object;
                const { x, y, z, occupied } = cell.userData;
                
                if (!occupied) {
                    makeMove(cell, x, y, z);
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (!isDragging) return;
            
            const touch = event.touches[0];
            const deltaMove = {
                x: touch.clientX - previousMousePosition.x,
                y: touch.clientY - previousMousePosition.y
            };
            
            // Rotación más suave y responsiva
            targetRotation.y += deltaMove.x * 0.02;
            targetRotation.x += deltaMove.y * 0.02;
            
            // Limitar la rotación vertical para evitar que el cubo se voltee
            targetRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotation.x));
            
            previousMousePosition = {
                x: touch.clientX,
                y: touch.clientY
            };
            
            // Actualizar el cursor
            document.body.style.cursor = 'grabbing';
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            isDragging = false;
            document.body.style.cursor = 'grab';
        }
        
        function makeMove(cell, x, y, z) {
            // Marcar celda como ocupada
            cell.userData.occupied = true;
            
            // Cambiar apariencia de la celda
            const playerColor = playerColors[currentPlayer];
            cell.userData.wireframe.material.color.setHex(playerColor);
            cell.userData.wireframe.material.opacity = 1;
            cell.userData.glowMesh.material.color.setHex(playerColor);
            cell.userData.glowMesh.material.opacity = 0.2;
            cell.userData.material.opacity = 0.2;
            cell.userData.material.color.setHex(playerColor);
            
            // Crear símbolo
            let piece;
            if (currentPlayer === 'X') {
                piece = createX(cell.position, cell.userData.cellGroup);
            } else if (currentPlayer === 'O') {
                piece = createO(cell.position, cell.userData.cellGroup);
            } else {
                piece = createZ(cell.position, cell.userData.cellGroup);
            }
            
            // Actualizar estado del juego
            gameState[x][y][z] = currentPlayer;
            
            // Verificar ganador
            if (checkWinner(currentPlayer)) {
                gameOver = true;
                document.getElementById('winner').innerHTML = 
                    `<span class="player-${currentPlayer.toLowerCase()}">PLAYER ${currentPlayer} WINS!</span>`;
                highlightWinningLine(currentPlayer);
            } else if (checkDraw()) {
                gameOver = true;
                document.getElementById('winner').textContent = 'DRAW!';
            } else {
                // Cambiar turno
                const playerIndex = players.indexOf(currentPlayer);
                currentPlayer = players[(playerIndex + 1) % players.length];
                document.getElementById('info').innerHTML = 
                    `PLAYER <span class="player-${currentPlayer.toLowerCase()}">${currentPlayer}</span> TURN`;
            }
        }
        
        function checkWinner(player) {
            const lines = getAllWinningLines();
            
            for (let line of lines) {
                const validCells = line.filter(([x, y, z]) => {
                    // Skip center if hidden
                    if (hideCenter && x === 1 && y === 1 && z === 1) {
                        return false;
                    }
                    return true;
                });
                
                if (validCells.length >= 3 && 
                    validCells.every(([x, y, z]) => gameState[x][y][z] === player)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function getAllWinningLines() {
            const lines = [];
            
            // Líneas horizontales, verticales y profundidad
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    // Líneas en X
                    lines.push([[0, i, j], [1, i, j], [2, i, j]]);
                    // Líneas en Y
                    lines.push([[i, 0, j], [i, 1, j], [i, 2, j]]);
                    // Líneas en Z
                    lines.push([[i, j, 0], [i, j, 1], [i, j, 2]]);
                }
                
                // Diagonales 2D en cada plano
                lines.push([[0, 0, i], [1, 1, i], [2, 2, i]]);
                lines.push([[2, 0, i], [1, 1, i], [0, 2, i]]);
                lines.push([[0, i, 0], [1, i, 1], [2, i, 2]]);
                lines.push([[2, i, 0], [1, i, 1], [0, i, 2]]);
                lines.push([[i, 0, 0], [i, 1, 1], [i, 2, 2]]);
                lines.push([[i, 2, 0], [i, 1, 1], [i, 0, 2]]);
            }
            
            // Diagonales 3D principales
            lines.push([[0, 0, 0], [1, 1, 1], [2, 2, 2]]);
            lines.push([[2, 0, 0], [1, 1, 1], [0, 2, 2]]);
            lines.push([[0, 2, 0], [1, 1, 1], [2, 0, 2]]);
            lines.push([[2, 2, 0], [1, 1, 1], [0, 0, 2]]);
            
            return lines;
        }
        
        function highlightWinningLine(player) {
            const lines = getAllWinningLines();
            const color = playerColors[player];
            
            for (let line of lines) {
                const validCells = line.filter(([x, y, z]) => {
                    if (hideCenter && x === 1 && y === 1 && z === 1) {
                        return false;
                    }
                    return true;
                });
                
                if (validCells.length >= 3 && 
                    validCells.every(([x, y, z]) => gameState[x][y][z] === player)) {
                    validCells.forEach(([x, y, z]) => {
                        const cell = cells.find(c => 
                            c.userData.x === x && 
                            c.userData.y === y && 
                            c.userData.z === z
                        );
                        
                        if (cell) {
                            const wireframe = cell.userData.wireframe;
                            wireframe.material.color.setHex(0xffffff);
                            wireframe.material.opacity = 1;
                            
                            // Animación de victoria
                            const cellGroup = cell.userData.cellGroup;
                            function victoryAnimation() {
                                const scale = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                                cellGroup.scale.setScalar(scale);
                                cellGroup.rotation.y += 0.02;
                                
                                if (gameOver) {
                                    requestAnimationFrame(victoryAnimation);
                                }
                            }
                            victoryAnimation();
                        }
                    });
                    break;
                }
            }
        }
        
        function checkDraw() {
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        if (hideCenter && x === 1 && y === 1 && z === 1) {
                            continue;
                        }
                        if (gameState[x][y][z] === null) return false;
                    }
                }
            }
            return true;
        }
        
        function resetGame() {
            // Limpiar la escena
            while(cubeGroup.children.length > 0) {
                cubeGroup.remove(cubeGroup.children[0]);
            }
            cells = [];
            
            // Reiniciar estado
            initGameState();
            currentPlayer = 'X';
            gameOver = false;
            document.getElementById('info').innerHTML = 'PLAYER <span class="player-x">X</span> TURN';
            document.getElementById('winner').textContent = '';
            
            // Recrear el cubo
            createCube();
        }
        
        function resetCamera() {
            targetRotation = { x: 0, y: 0 };
            camera.position.set(5, 4, 5);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleSettings() {
            const settings = document.getElementById('settings');
            const overlay = document.getElementById('settingsOverlay');
            const isShowing = settings.classList.contains('show');
            
            if (isShowing) {
                settings.classList.remove('show');
                overlay.classList.remove('show');
            } else {
                settings.classList.add('show');
                overlay.classList.add('show');
            }
        }
        
        function toggleHideCenter() {
            hideCenter = !hideCenter;
            document.getElementById('hideCenterToggle').classList.toggle('active');
            resetGame();
        }
        
        function toggleThreePlayers() {
            threePlayers = !threePlayers;
            players = threePlayers ? ['X', 'O', 'Z'] : ['X', 'O'];
            document.getElementById('threePlayersToggle').classList.toggle('active');
            resetGame();
        }
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('autoRotateToggle').classList.toggle('active');
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotación más suave con interpolación
            const rotationSpeed = 0.1;
            currentRotation.x += (targetRotation.x - currentRotation.x) * rotationSpeed;
            currentRotation.y += (targetRotation.y - currentRotation.y) * rotationSpeed;
            
            // Auto rotación más suave
            if (autoRotate && !isDragging) {
                targetRotation.y += 0.002;
                targetRotation.x = Math.sin(Date.now() * 0.0002) * 0.1;
            }
            
            // Aplicar rotación con suavizado
            cubeGroup.rotation.x = currentRotation.x;
            cubeGroup.rotation.y = currentRotation.y;
            
            // Renderizar
            renderer.render(scene, camera);
        }
        
        // Iniciar cuando la página cargue
        window.addEventListener('load', init);
        
        // Cerrar configuración al hacer clic fuera
        document.getElementById('settingsOverlay').addEventListener('click', toggleSettings);
        
        // Prevenir que los clics en el modal cierren la configuración
        document.getElementById('settings').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Cerrar configuración con la tecla Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('settings').classList.contains('show')) {
                toggleSettings();
            }
        });
        
        // Cerrar configuración al tocar fuera (para dispositivos táctiles)
        document.getElementById('settingsOverlay').addEventListener('touchstart', (e) => {
            if (e.target === e.currentTarget) {
                toggleSettings();
            }
        });
    </script>
</body>
</html>